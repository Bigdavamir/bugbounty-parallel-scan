name: XSS Summary

on:
  workflow_run: # Trigger this workflow when 'XSS Tools Execution' completes
    workflows: ["XSS Tools Execution"] # Name of the workflow file (xss-tools.yaml)
    types:
      - completed

jobs:
  # Dummy job to satisfy GitHub Actions requirement for a starting point
  start:
    runs-on: ubuntu-latest
    # Only run if the previous workflow completed successfully
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    steps:
      - name: This job is just a placeholder
        run: echo "Starting the summary workflow..."

  # Job 7: Final summary
  final-summary:
    # Depend on the placeholder job within this workflow
    needs: [start]
    runs-on: ubuntu-latest
    # Only run if the previous workflow completed successfully
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    steps:
      - name: Download all artifacts from previous workflows
        uses: actions/download-artifact@v4
        with:
          pattern: "*" # Downloads all artifacts from httpx, x8, kxss jobs
          merge-multiple: true

      - name: Generate final summary
        run: |
          # Set domain variable - assuming it's passed or available from previous run context
          # If this workflow is triggered by workflow_run, inputs might not be directly available.
          # You might need to find a way to pass the domain, e.g., via an artifact or env variable.
          # For now, using a placeholder if inputs.domain is not accessible.
          DOMAIN="${{ inputs.domain }}"
          if [[ -z "$DOMAIN" ]]; then
            # Attempt to get domain from workflow run context if possible, otherwise use placeholder
            # This is a common challenge with workflow_run triggers.
            # For now, we'll try to get it from the artifact pattern if possible, or use placeholder.
            # A more robust solution involves passing the domain via an artifact file.
            echo "Domain input not directly available in workflow_run context. Attempting to find from artifacts..."
            # Example: Try to find domain from artifact name patterns if they contain it.
            # This is a heuristic and might not always work.
            DOMAIN=$(find . -name "FINAL-RESULTS-*" | head -n 1 | sed 's/FINAL-RESULTS-\(.*\)/\1/' || echo "target-domain.com")
            if [[ "$DOMAIN" == "target-domain.com" ]]; then
                echo "Could not determine domain from artifact names, using placeholder: $DOMAIN"
            else
                echo "Determined domain from artifact name: $DOMAIN"
            fi
          fi


          # Combine all results
          find . -name "httpx-results-*" -type d -exec cat {}/*.txt \; > httpx.txt || true
          find . -name "httpx-results-*" -type d -exec grep '?' {}/*.txt \; > dynamic-httpx.txt || true
          find . -name "x8-results-*" -type d -exec cat {}/*.txt \; > x8-brute.txt || true
          find . -name "kxss-results-*" -type d -exec cat {}/*.txt \; > kxss-out.txt || true

          # Parse kxss output for reflected pairs
          awk '
          /^URL: .* Param: .* Unfiltered: / {
            url_start = index($0, "URL: ") + 5
            param_pos = index($0, " Param: ")
            url = substr($0, url_start, param_pos - url_start)

            param_start = param_pos + 8
            unfilt_pos = index($0, " Unfiltered: ")
            param = substr($0, param_start, unfilt_pos - param_start)

            unfilt_start = unfilt_pos + 13
            unfiltered = substr($0, unfilt_start)

            if (unfiltered != "[]" && unfiltered != "" && url != "" && param != "") {
              print url " | " param " | Unfiltered: " unfiltered
            }
          }
          ' kxss-out.txt > kxss-reflected-pairs.txt

          # Helper function to count lines in a file, returns 0 if file doesn't exist
          count_or_zero(){
            [[ -f "$1" ]] && wc -l < "$1" || echo 0
          }

          # Generate summary counts
          # These counts depend on artifacts from the FIRST workflow (url-gathering.yaml)
          # If they are not downloaded, these counts will be 0.
          # To ensure these are available, you might need to explicitly download artifacts from url-gathering.yaml too.
          # For now, assuming 'merge-multiple: true' handles it if they are in the root.
          # If not, add specific 'download-artifact' steps for wayback and gau results.
          WAYBACK_COUNT=$(count_or_zero passive-wayback/waybackurls.txt) # Might be 0 if artifact not downloaded
          GAU_COUNT=$(count_or_zero passive-gau/gau.txt)             # Might be 0 if artifact not downloaded
          ALLURLS_COUNT=$(count_or_zero combined-results/all-urls.txt)
          STATIC_COUNT=$(grep -iv "?" combined-results/all-urls.txt 2>/dev/null | sort -u | wc -l || echo 0)
          DYNAMIC_COUNT=$(count_or_zero dynamic-httpx.txt)
          HTTPX_COUNT=$(count_or_zero httpx.txt)
          UNFURLPARAMS_COUNT=$(count_or_zero combined-results/unfurl-params.txt)
          X8_COUNT=$(count_or_zero x8-brute.txt)
          KXSS_COUNT=$(count_or_zero kxss-out.txt)

          # Print summary to console using echo
          echo "============ Recon Summary for $DOMAIN ============"
          echo "waybackurls: $WAYBACK_COUNT"
          echo "gau: $GAU_COUNT"
          echo "All unique URLs: $ALLURLS_COUNT"
          echo "Static URLs: $STATIC_COUNT"
          echo "Dynamic URLs: $DYNAMIC_COUNT"
          echo "Unique URL params: $UNFURLPARAMS_COUNT"
          echo "httpx (alive URLs): $HTTPX_COUNT"
          echo "x8 reflections lines: $X8_COUNT"
          echo "kxss scan lines: $KXSS_COUNT"
          # Check if headers were provided in the original trigger, if so, print them.
          # Note: Accessing original inputs might be tricky with workflow_run.
          # If domain/headers were passed to the first workflow, they might not be directly available here.
          # The 'inputs.domain' used above is an attempt to get it.
          # Headers might need to be passed differently, e.g., via an artifact file.
          if [[ -n "${{ github.event.inputs.headers }}" ]]; then # This input might not be available.
            echo "Headers used: ${{ github.event.inputs.headers }}"
          fi
          echo "=================================================="

          # Save summary to file using echo
          mkdir -p final-results
          echo "============ Recon Summary for $DOMAIN ============" > final-results/FINAL_SUMMARY.txt
          echo "waybackurls: $WAYBACK_COUNT" >> final-results/FINAL_SUMMARY.txt
          echo "gau: $GAU_COUNT" >> final-results/FINAL_SUMMARY.txt
          echo "All unique URLs: $ALLURLS_COUNT" >> final-results/FINAL_SUMMARY.txt
          echo "Static URLs: $STATIC_COUNT" >> final-results/FINAL_SUMMARY.txt
          echo "Dynamic URLs: $DYNAMIC_COUNT" >> final-results/FINAL_SUMMARY.txt
          echo "Unique URL params: $UNFURLPARAMS_COUNT" >> final-results/FINAL_SUMMARY.txt
          echo "httpx (alive URLs): $HTTPX_COUNT" >> final-results/FINAL_SUMMARY.txt
          echo "x8 reflections lines: $X8_COUNT" >> final-results/FINAL_SUMMARY.txt
          echo "kxss scan lines: $KXSS_COUNT" >> final-results/FINAL_SUMMARY.txt
          if [[ -n "${{ github.event.inputs.headers }}" ]]; then # Again, input might not be available.
            echo "Headers used: ${{ github.event.inputs.headers }}" >> final-results/FINAL_SUMMARY.txt
          fi
          echo "==================================================" >> final-results/FINAL_SUMMARY.txt

          # Show reflected pairs (first 5)
          if [[ -s "kxss-reflected-pairs.txt" ]]; then
            echo "[*] First 5 reflected pairs:"
            head -5 "kxss-reflected-pairs.txt"
          else
            echo "[!] No reflected pairs found."
          fi

          # Health check
          if grep -q "1.bigdav.ir" "kxss-reflected-pairs.txt"; then
            echo "[✓] Health check passed."
          else
            echo "[✗] Health check failed."
          fi

          # Save other combined results for upload
          cp httpx.txt final-results/ || true
          cp dynamic-httpx.txt final-results/ || true
          cp x8-brute.txt final-results/ || true
          cp kxss-out.txt final-results/ || true
          cp kxss-reflected-pairs.txt final-results/ || true

          # Copy the generated summary file to the final-results directory as well
          cp final-results/FINAL_SUMMARY.txt final-results/ || true

      - name: Upload final results
        uses: actions/upload-artifact@v4
        with:
          name: FINAL-RESULTS-${{ inputs.domain }} # Domain input might not be available here. Adjust if needed.
          path: final-results/

