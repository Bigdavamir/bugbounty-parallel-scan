name: XSS Tools Execution

on:
  workflow_call:
    inputs:
      domain:
        required: true
        type: string
      headers:
        required: false
        type: string
      run_id:
        required: true
        type: string

jobs:
  httpx-scan:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        chunk: [1, 2, 3, 4, 5, 6, 7, 8]
    steps:
      - name: Restore combined results
        uses: actions/cache@v4
        with:
          path: combined-results/
          key: combined-results-${{ inputs.run_id }}
          restore-keys: |
            combined-results-

      - name: Debug dynamic-urls
        run: |
          echo "==== combined-results/dynamic-urls.txt preview ===="
          if [[ -f combined-results/dynamic-urls.txt ]]; then
            head -10 combined-results/dynamic-urls.txt
            wc -l combined-results/dynamic-urls.txt
          else
            echo "combined-results/dynamic-urls.txt not found!"
          fi

      - name: Install httpx with PATH fix
        run: |
          go install github.com/projectdiscovery/httpx/cmd/httpx@latest
          echo "export PATH=\$PATH:\$(go env GOPATH)/bin" >> $GITHUB_ENV
          export PATH=$PATH:$(go env GOPATH)/bin
          echo "Go PATH: $(go env GOPATH)"
          echo "Current PATH: $PATH"
          echo "httpx location: $(which httpx || echo 'not found in PATH')"
          echo "$(go env GOPATH)/bin" >> $GITHUB_PATH

      - name: Run httpx on chunk
        run: |
          mkdir -p httpx-results-${{ matrix.chunk }}
          export PATH=$PATH:$(go env GOPATH)/bin
          if [[ -f "combined-results/dynamic-urls.txt" ]] && [[ -s "combined-results/dynamic-urls.txt" ]]; then
            TOTAL_LINES=$(wc -l < combined-results/dynamic-urls.txt)
            LINES_PER_CHUNK=$((TOTAL_LINES / 8 + 1))
            START_LINE=$((((${{ matrix.chunk }} - 1) * LINES_PER_CHUNK) + 1))
            END_LINE=$((${{ matrix.chunk }} * LINES_PER_CHUNK))
            sed -n "${START_LINE},${END_LINE}p" combined-results/dynamic-urls.txt > chunk-${{ matrix.chunk }}.txt
            if [[ -s "chunk-${{ matrix.chunk }}.txt" ]]; then
              echo "Processing chunk ${{ matrix.chunk }} with $(wc -l < chunk-${{ matrix.chunk }}.txt) URLs"
              cat chunk-${{ matrix.chunk }}.txt | httpx -silent -threads 30 -timeout 10 -retries 2 -status-code -follow-redirects -rate-limit 10 > httpx-results-${{ matrix.chunk }}/httpx.txt || {
                echo "httpx failed for chunk ${{ matrix.chunk }}, using input URLs as fallback"
                cp chunk-${{ matrix.chunk }}.txt httpx-results-${{ matrix.chunk }}/httpx.txt
              }
            else
              touch httpx-results-${{ matrix.chunk }}/httpx.txt
            fi
          else
            touch httpx-results-${{ matrix.chunk }}/httpx.txt
          fi
          ALIVE_COUNT=$(wc -l < httpx-results-${{ matrix.chunk }}/httpx.txt)
          echo "Chunk ${{ matrix.chunk }} found $ALIVE_COUNT alive URLs"
          
          # Create a marker file to verify this job completed successfully
          echo "Job completed" > httpx-results-${{ matrix.chunk }}/job_completed.marker

      - name: Debug httpx-results dir after scan
        run: |
          echo "httpx-results-${{ matrix.chunk }}/ content:"
          ls -l httpx-results-${{ matrix.chunk }}/ || true
          head -10 httpx-results-${{ matrix.chunk }}/httpx.txt || true

      - name: Cache httpx results
        uses: actions/cache@v4
        with:
          path: httpx-results-${{ matrix.chunk }}/
          key: httpx-results-${{ matrix.chunk }}-${{ inputs.run_id }}

  x8-scan:
    needs: httpx-scan
    runs-on: ubuntu-latest
    strategy:
      matrix:
        chunk: [1, 2, 3, 4]
    steps:
      - name: Restore combined results
        uses: actions/cache@v4
        with:
          path: combined-results/
          key: combined-results-${{ inputs.run_id }}
          restore-keys: |
            combined-results-

      - name: Restore all httpx results
        id: cache-httpx
        uses: actions/cache@v4
        with:
          path: |
            httpx-results-1/
            httpx-results-2/
            httpx-results-3/
            httpx-results-4/
            httpx-results-5/
            httpx-results-6/
            httpx-results-7/
            httpx-results-8/
          key: not-used
          restore-keys: |
            httpx-results-1-${{ inputs.run_id }}
            httpx-results-2-${{ inputs.run_id }}
            httpx-results-3-${{ inputs.run_id }}
            httpx-results-4-${{ inputs.run_id }}
            httpx-results-5-${{ inputs.run_id }}
            httpx-results-6-${{ inputs.run_id }}
            httpx-results-7-${{ inputs.run_id }}
            httpx-results-8-${{ inputs.run_id }}

      - name: Debug all httpx cache presence
        run: |
          echo "==== httpx-results-* directory list ===="
          ls -l httpx-results-*/ || echo "No httpx result directories found"
          for d in httpx-results-*; do 
            if [ -d "$d" ]; then
              echo "$d:"; 
              ls -la $d/ || echo "No files in $d"
              head -10 $d/*.txt 2>/dev/null || echo "No text files in $d or files are empty"
            fi
          done

      - name: Create fallback httpx results if cache failed
        if: steps.cache-httpx.outputs.cache-hit != 'true'
        run: |
          echo "Creating fallback httpx results because cache restore failed"
          if [[ -f "combined-results/dynamic-urls.txt" ]] && [[ -s "combined-results/dynamic-urls.txt" ]]; then
            go install github.com/projectdiscovery/httpx/cmd/httpx@latest
            export PATH=$PATH:$(go env GOPATH)/bin
            
            # Create fallback directories for all chunks
            for i in {1..8}; do
              mkdir -p httpx-results-$i
              touch httpx-results-$i/httpx.txt
            done
            
            # Process a small subset for this job as fallback
            TOTAL_LINES=$(wc -l < combined-results/dynamic-urls.txt)
            MAX_FALLBACK=500  # Limit fallback processing to avoid long runtime
            if [ $TOTAL_LINES -gt $MAX_FALLBACK ]; then
              head -$MAX_FALLBACK combined-results/dynamic-urls.txt > fallback-urls.txt
            else
              cp combined-results/dynamic-urls.txt fallback-urls.txt
            fi
            
            echo "Running fallback httpx scan on $(wc -l < fallback-urls.txt) URLs"
            cat fallback-urls.txt | httpx -silent -threads 30 -timeout 10 -retries 2 -status-code -follow-redirects -rate-limit 10 > all-httpx-results.txt || true
            
            # Distribute results across all chunks
            split -n l/8 all-httpx-results.txt httpx-split-
            
            # Move split files to appropriate directories
            i=1
            for f in httpx-split-*; do
              if [ -s "$f" ]; then
                cp $f httpx-results-$i/httpx.txt
              fi
              i=$((i+1))
              if [ $i -gt 8 ]; then
                break
              fi
            done
          else
            echo "No dynamic-urls.txt found or it's empty, creating empty httpx results"
            for i in {1..8}; do
              mkdir -p httpx-results-$i
              touch httpx-results-$i/httpx.txt
            done
          fi

      - name: Install x8
        run: |
          wget https://github.com/Sh1Yo/x8/releases/latest/download/x8-linux-x86_64 -O x8 && chmod +x x8 && sudo mv x8 /usr/local/bin/ && command -v x8 && echo "x8 installed via direct download" && exit 0 || echo "Direct download failed, trying cargo..."
          curl https://sh.rustup.rs -sSf | sh -s -- -y
          source "$HOME/.cargo/env"
          cargo install x8 && echo "x8 installed via cargo" && exit 0 || echo "Cargo install failed, trying build from source..."
          if command -v go >/dev/null 2>&1; then
            if ! command -v x8 >/dev/null 2>&1; then
              echo "Building from source failed. Creating a fallback script..."
            fi
          fi
          echo '#!/bin/bash' > /usr/local/bin/x8_fallback.sh
          echo 'echo "Simulating x8 functionality: URL="$1" WORDLIST="$2"' >> /usr/local/bin/x8_fallback.sh
          echo 'echo "Error: Fallback script executed. Real x8 not found. Please check installation."' >> /usr/local/bin/x8_fallback.sh
          chmod +x /usr/local/bin/x8_fallback.sh
          if ! command -v x8 >/dev/null 2>&1; then
              echo "x8 not found, using fallback script via alias."
              echo "alias x8='/usr/local/bin/x8_fallback.sh'" >> $GITHUB_ENV
              export PATH=$PATH:/usr/local/bin
          else
            echo "x8 found in PATH."
          fi

      - name: Combine httpx results and run x8
        run: |
          mkdir -p x8-results-${{ matrix.chunk }}
          # Find any files in httpx results directories
          echo "Searching for httpx results..."
          find . -name "httpx-results-*" -type d | xargs -I{} ls -la {} || echo "No httpx result directories found"
          
          # Combine all httpx results, with extensive error handling
          echo "Combining httpx results..."
          if find . -name "httpx-results-*" -type d -exec test -s {}/*.txt \; -print | grep -q .; then
            find . -name "httpx-results-*" -type d -exec cat {}/*.txt \; 2>/dev/null | grep '?' | sort -u > dynamic-alive.txt || true
          elif [ -f "combined-results/dynamic-urls.txt" ]; then
            echo "No valid httpx results found, using dynamic-urls.txt as fallback"
            grep '?' combined-results/dynamic-urls.txt | sort -u > dynamic-alive.txt || touch dynamic-alive.txt
          else
            echo "No valid httpx results or dynamic-urls.txt found, creating empty file"
            touch dynamic-alive.txt
          fi
          
          echo "dynamic-alive.txt preview:"
          head -10 dynamic-alive.txt || true
          echo "Total URLs: $(wc -l < dynamic-alive.txt 2>/dev/null || echo 0)"
          
          if [[ -s "dynamic-alive.txt" ]] && [[ -s "combined-results/unfurl-params.txt" ]]; then
            TOTAL_LINES=$(wc -l < dynamic-alive.txt)
            LINES_PER_CHUNK=$((TOTAL_LINES / 4 + 1))
            START_LINE=$((((${{ matrix.chunk }} - 1) * LINES_PER_CHUNK) + 1))
            END_LINE=$((${{ matrix.chunk }} * LINES_PER_CHUNK))
            sed -n "${START_LINE},${END_LINE}p" dynamic-alive.txt > x8-chunk-${{ matrix.chunk }}.txt
            if [[ -s "x8-chunk-${{ matrix.chunk }}.txt" ]]; then
              if [[ -n "${{ inputs.headers }}" ]]; then
                cat x8-chunk-${{ matrix.chunk }}.txt | xargs -P 4 -I{} x8 -u "{}" -w combined-results/unfurl-params.txt -X GET POST -H "${{ inputs.headers }}" > x8-results-${{ matrix.chunk }}/x8.txt || true
              else
                cat x8-chunk-${{ matrix.chunk }}.txt | xargs -P 4 -I{} x8 -u "{}" -w combined-results/unfurl-params.txt -X GET POST > x8-results-${{ matrix.chunk }}/x8.txt || true
              fi
            else
              touch x8-results-${{ matrix.chunk }}/x8.txt
            fi
          else
            touch x8-results-${{ matrix.chunk }}/x8.txt
          fi

      - name: Debug x8 output
        run: |
          echo "x8-results-${{ matrix.chunk }}/ content:"
          ls -l x8-results-${{ matrix.chunk }}/ || true
          head -10 x8-results-${{ matrix.chunk }}/x8.txt || true

      - name: Cache x8 results
        uses: actions/cache@v4
        with:
          path: x8-results-${{ matrix.chunk }}/
          key: x8-results-${{ matrix.chunk }}-${{ inputs.run_id }}

  kxss-scan:
    needs: httpx-scan
    runs-on: ubuntu-latest
    strategy:
      matrix:
        chunk: [1, 2, 3, 4, 5, 6]
    steps:
      - name: Restore combined results
        uses: actions/cache@v4
        with:
          path: combined-results/
          key: combined-results-${{ inputs.run_id }}
          restore-keys: |
            combined-results-

      - name: Restore all httpx results
        id: cache-httpx-kxss
        uses: actions/cache@v4
        with:
          path: |
            httpx-results-1/
            httpx-results-2/
            httpx-results-3/
            httpx-results-4/
            httpx-results-5/
            httpx-results-6/
            httpx-results-7/
            httpx-results-8/
          key: not-used
          restore-keys: |
            httpx-results-1-${{ inputs.run_id }}
            httpx-results-2-${{ inputs.run_id }}
            httpx-results-3-${{ inputs.run_id }}
            httpx-results-4-${{ inputs.run_id }}
            httpx-results-5-${{ inputs.run_id }}
            httpx-results-6-${{ inputs.run_id }}
            httpx-results-7-${{ inputs.run_id }}
            httpx-results-8-${{ inputs.run_id }}

      - name: Debug all httpx cache presence
        run: |
          echo "==== httpx-results-* directory list ===="
          ls -l httpx-results-*/ || echo "No httpx result directories found"
          for d in httpx-results-*; do 
            if [ -d "$d" ]; then
              echo "$d:"; 
              ls -la $d/ || echo "No files in $d"
              head -10 $d/*.txt 2>/dev/null || echo "No text files in $d or files are empty"
            fi
          done

      - name: Create fallback httpx results if cache failed
        if: steps.cache-httpx-kxss.outputs.cache-hit != 'true'
        run: |
          echo "Creating fallback httpx results because cache restore failed"
          if [[ -f "combined-results/dynamic-urls.txt" ]] && [[ -s "combined-results/dynamic-urls.txt" ]]; then
            go install github.com/projectdiscovery/httpx/cmd/httpx@latest
            export PATH=$PATH:$(go env GOPATH)/bin
            
            # Create fallback directories for all chunks
            for i in {1..8}; do
              mkdir -p httpx-results-$i
              touch httpx-results-$i/httpx.txt
            done
            
            # Process a small subset for this job as fallback
            TOTAL_LINES=$(wc -l < combined-results/dynamic-urls.txt)
            MAX_FALLBACK=500  # Limit fallback processing to avoid long runtime
            if [ $TOTAL_LINES -gt $MAX_FALLBACK ]; then
              head -$MAX_FALLBACK combined-results/dynamic-urls.txt > fallback-urls.txt
            else
              cp combined-results/dynamic-urls.txt fallback-urls.txt
            fi
            
            echo "Running fallback httpx scan on $(wc -l < fallback-urls.txt) URLs"
            cat fallback-urls.txt | httpx -silent -threads 30 -timeout 10 -retries 2 -status-code -follow-redirects -rate-limit 10 > all-httpx-results.txt || true
            
            # Distribute results across all chunks
            split -n l/8 all-httpx-results.txt httpx-split-
            
            # Move split files to appropriate directories
            i=1
            for f in httpx-split-*; do
              if [ -s "$f" ]; then
                cp $f httpx-results-$i/httpx.txt
              fi
              i=$((i+1))
              if [ $i -gt 8 ]; then
                break
              fi
            done
          else
            echo "No dynamic-urls.txt found or it's empty, creating empty httpx results"
            for i in {1..8}; do
              mkdir -p httpx-results-$i
              touch httpx-results-$i/httpx.txt
            done
          fi

      - name: Install kxss
        run: |
          go install github.com/Emoe/kxss@latest
          echo "$(go env GOPATH)/bin" >> $GITHUB_PATH

      - name: Generate kxss URLs and run scan
        run: |
          mkdir -p kxss-results-${{ matrix.chunk }}
          export PATH=$PATH:$(go env GOPATH)/bin
          
          # Combine all httpx results, with extensive error handling
          echo "Combining httpx results..."
          if find . -name "httpx-results-*" -type d -exec test -s {}/*.txt \; -print | grep -q .; then
            find . -name "httpx-results-*" -type d -exec cat {}/*.txt \; 2>/dev/null | grep '?' | sort -u > dynamic-alive.txt || true
          elif [ -f "combined-results/dynamic-urls.txt" ]; then
            echo "No valid httpx results found, using dynamic-urls.txt as fallback"
            grep '?' combined-results/dynamic-urls.txt | sort -u > dynamic-alive.txt || touch dynamic-alive.txt
          else
            echo "No valid httpx results or dynamic-urls.txt found, creating empty file"
            touch dynamic-alive.txt
          fi
          
          echo "dynamic-alive.txt preview:"
          head -10 dynamic-alive.txt || true
          echo "Total URLs: $(wc -l < dynamic-alive.txt 2>/dev/null || echo 0)"

          if [[ -s "dynamic-alive.txt" ]] && [[ -s "combined-results/unfurl-params.txt" ]]; then
            TOTAL_LINES=$(wc -l < dynamic-alive.txt)
            LINES_PER_CHUNK=$((TOTAL_LINES / 6 + 1))
            START_LINE=$((((${{ matrix.chunk }} - 1) * LINES_PER_CHUNK) + 1))
            END_LINE=$((${{ matrix.chunk }} * LINES_PER_CHUNK))

            sed -n "${START_LINE},${END_LINE}p" dynamic-alive.txt > kxss-urls-${{ matrix.chunk }}.txt

            if [[ -s "kxss-urls-${{ matrix.chunk }}.txt" ]]; then
              echo "Running kxss for chunk ${{ matrix.chunk }}..."
              cat kxss-urls-${{ matrix.chunk }}.txt | httpx -silent -threads 30 -timeout 10 -retries 2 -status-code -follow-redirects -rate-limit 10 |
              while IFS= read -r url; do
                if [[ -f "combined-results/unfurl-params.txt" ]]; then
                  while IFS= read -r param; do
                    echo "$url?${param}=KXSS"
                  done < combined-results/unfurl-params.txt
                else
                  echo "$url"
                fi
              done | sort -u > kxss-urls-final-${{ matrix.chunk }}.txt

              if [[ -s "kxss-urls-final-${{ matrix.chunk }}.txt" ]]; then
                cat kxss-urls-final-${{ matrix.chunk }}.txt | kxss -timeout 300 -threads 50 > kxss-results-${{ matrix.chunk }}/kxss-output.txt || {
                  echo "kxss scan failed for chunk ${{ matrix.chunk }}"
                  touch kxss-results-${{ matrix.chunk }}/kxss-output.txt
                }
              else
                touch kxss-results-${{ matrix.chunk }}/kxss-output.txt
              fi
            else
              touch kxss-results-${{ matrix.chunk }}/kxss-output.txt
            fi
          else
            touch kxss-results-${{ matrix.chunk }}/kxss-output.txt
          fi

          KXSS_COUNT=$(wc -l < kxss-results-${{ matrix.chunk }}/kxss-output.txt)
          echo "kxss found $KXSS_COUNT results for chunk ${{ matrix.chunk }}"

      - name: Debug kxss output
        run: |
          echo "kxss-results-${{ matrix.chunk }}/ content:"
          ls -l kxss-results-${{ matrix.chunk }}/ || true
          head -10 kxss-results-${{ matrix.chunk }}/kxss-output.txt || true

      - name: Cache kxss results
        uses: actions/cache@v4
        with:
          path: kxss-results-${{ matrix.chunk }}/
          key: kxss-results-${{ matrix.chunk }}-${{ inputs.run_id }}
