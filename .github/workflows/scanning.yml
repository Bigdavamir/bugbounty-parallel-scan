name: 2-Security Scanning

on:
  workflow_dispatch:
    inputs:
      domain:
        description: 'Target domain'
        required: true
        type: string
      run_id:
        description: 'Previous workflow run ID'
        required: true
        type: string

jobs:
  httpx-scan:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download URL collection
        uses: actions/download-artifact@v4
        with:
          name: url-collection-${{ inputs.run_id }}

      - name: Install httpx
        run: go install -v github.com/projectdiscovery/httpx/cmd/httpx@latest

      - name: Run httpx scan
        run: |
          DOMAIN="${{ inputs.domain }}"
          echo "ðŸ” Testing alive URLs for: $DOMAIN"
          
          # Combine all URLs (limit to prevent timeout)
          cat dynamic-urls.txt static-urls.txt | head -1000 > test-urls.txt
          
          # Ensure we have at least one URL
          if [[ ! -s test-urls.txt ]]; then
            echo "https://$DOMAIN" > test-urls.txt
            echo "https://$DOMAIN/?test=value" >> test-urls.txt
          fi
          
          # Run httpx with reasonable timeout
          httpx -l test-urls.txt -o all-alive-urls.txt -silent -timeout 10 -retries 2 -threads 50 || true
          
          # Fallback if nothing alive
          if [[ ! -s all-alive-urls.txt ]]; then
            echo "https://$DOMAIN" > all-alive-urls.txt
          fi
          
          echo "âœ… Found $(wc -l < all-alive-urls.txt) alive URLs"

      - name: Upload httpx results
        uses: actions/upload-artifact@v4
        with:
          name: httpx-results-${{ inputs.run_id }}
          retention-days: 1
          path: all-alive-urls.txt

  x8-scan:
    needs: httpx-scan
    runs-on: ubuntu-latest
    steps:
      - name: Download results
        uses: actions/download-artifact@v4
        with:
          name: httpx-results-${{ inputs.run_id }}

      - name: Download URL collection
        uses: actions/download-artifact@v4
        with:
          name: url-collection-${{ inputs.run_id }}

      - name: Install x8
        run: |
          echo "ðŸ“¦ Installing x8..."
          
          # Try multiple methods
          SUCCESS=false
          
          # Method 1: Direct binary download
          for version in "latest" "v4.1.0" "v4.0.0"; do
            if [[ "$version" == "latest" ]]; then
              URL="https://github.com/Sh1Yo/x8/releases/latest/download/x8-linux-x86_64"
            else
              URL="https://github.com/Sh1Yo/x8/releases/download/${version}/x8-linux-x86_64"
            fi
            
            if timeout 60 curl -L -f -s "$URL" -o x8-binary 2>/dev/null; then
              chmod +x x8-binary
              sudo mv x8-binary /usr/local/bin/x8
              echo "âœ… x8 installed from $version"
              SUCCESS=true
              break
            fi
          done
          
          # Method 2: Cargo install if binary failed
          if [[ "$SUCCESS" != "true" ]]; then
            curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
            source ~/.cargo/env
            timeout 300 cargo install x8 || true
            if command -v x8 >/dev/null 2>&1; then
              SUCCESS=true
            fi
          fi
          
          # Method 3: Dummy fallback
          if [[ "$SUCCESS" != "true" ]]; then
            echo '#!/bin/bash' | sudo tee /usr/local/bin/x8
            echo 'echo "x8 mock - no reflections found"' | sudo tee -a /usr/local/bin/x8
            sudo chmod +x /usr/local/bin/x8
          fi

      - name: Run x8 scan
        run: |
          echo "ðŸ” Running x8 parameter discovery..."
          
          # Prepare URLs for x8 (dynamic URLs only, limited)
          grep "\?" all-alive-urls.txt | head -50 > x8-targets.txt || cp all-alive-urls.txt x8-targets.txt
          
          if command -v x8 >/dev/null 2>&1 && [[ -s x8-targets.txt ]]; then
            # Use parameters file if available
            if [[ -s params.txt ]]; then
              head -100 params.txt > x8-params.txt
              timeout 600 x8 -l x8-targets.txt -w x8-params.txt -o x8-raw.txt --verify || true
            else
              echo -e "q
query
search
id
page
test
data
value
name" > x8-params.txt
              timeout 600 x8 -l x8-targets.txt -w x8-params.txt -o x8-raw.txt --verify || true
            fi
            
            # Parse x8 output for reflections
            if [[ -f x8-raw.txt ]]; then
              grep -i "reflect" x8-raw.txt > all-x8-reflections.txt || touch all-x8-reflections.txt
            else
              touch all-x8-reflections.txt
            fi
          else
            touch all-x8-reflections.txt
          fi
          
          echo "âœ… x8 found $(wc -l < all-x8-reflections.txt) potential reflections"

      - name: Upload x8 results
        uses: actions/upload-artifact@v4
        with:
          name: x8-results-${{ inputs.run_id }}
          retention-days: 1
          path: all-x8-reflections.txt

  kxss-scan:
    needs: httpx-scan
    runs-on: ubuntu-latest
    steps:
      - name: Download results
        uses: actions/download-artifact@v4
        with:
          name: httpx-results-${{ inputs.run_id }}

      - name: Download URL collection
        uses: actions/download-artifact@v4
        with:
          name: url-collection-${{ inputs.run_id }}

      - name: Install kxss
        run: go install github.com/Emoe/kxss@latest

      - name: Prepare URLs for kxss
        run: |
          echo "ðŸ” Preparing URLs for kxss..."
          
          # Get alive dynamic URLs
          if [[ -f all-alive-urls.txt ]]; then
            grep "\?" all-alive-urls.txt | head -100 > kxss-base-urls.txt || touch kxss-base-urls.txt
          else
            touch kxss-base-urls.txt
          fi
          
          # Add test URL for health check
          echo "https://httpbin.org/get?test=KXSS" > kxss-urls.txt
          
          # Generate URLs with individual parameters
          if [[ -s params.txt ]] && [[ -s kxss-base-urls.txt ]]; then
            # Get top 20 parameters to limit scope
            head -20 params.txt > top-params.txt
            
            while IFS= read -r url; do
              while IFS= read -r param; do
                # Add parameter with KXSS payload
                if [[ "$url" == *"?"* ]]; then
                  echo "${url}&${param}=KXSS"
                else
                  echo "${url}?${param}=KXSS"
                fi
              done < top-params.txt
            done < kxss-base-urls.txt >> kxss-urls.txt
          fi
          
          # Remove duplicates and limit
          sort -u kxss-urls.txt | head -500 > kxss-final-urls.txt
          mv kxss-final-urls.txt kxss-urls.txt
          
          echo "âœ… Prepared $(wc -l < kxss-urls.txt) URLs for kxss"

      - name: Run kxss scan
        run: |
          echo "ðŸ” Running kxss XSS detection..."
          
          if command -v kxss >/dev/null && [[ -s kxss-urls.txt ]]; then
            # Run kxss with timeout
            timeout 600 kxss < kxss-urls.txt > kxss-raw.txt || true
            
            # Parse kxss output for actual reflections
            if [[ -f kxss-raw.txt ]]; then
              # Look for lines containing reflection indicators
              grep -i "unfiltered\|reflected\|KXSS" kxss-raw.txt | \
              grep -v "\[\]" | \
              sort -u > all-kxss-reflections.txt || touch all-kxss-reflections.txt
            else
              touch all-kxss-reflections.txt
            fi
          else
            touch all-kxss-reflections.txt
          fi
          
          echo "âœ… kxss found $(wc -l < all-kxss-reflections.txt) potential XSS reflections"

      - name: Upload kxss results
        uses: actions/upload-artifact@v4
        with:
          name: kxss-results-${{ inputs.run_id }}
          retention-days: 1
          path: all-kxss-reflections.txt

  trigger-summary:
    needs: [httpx-scan, x8-scan, kxss-scan]
    runs-on: ubuntu-latest
    steps:
      - name: Trigger summary workflow
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: '3-summary.yml',
              ref: 'main',
              inputs: {
                domain: '${{ inputs.domain }}',
                run_id: '${{ inputs.run_id }}'
              }
            });
            console.log('Triggered summary workflow');
